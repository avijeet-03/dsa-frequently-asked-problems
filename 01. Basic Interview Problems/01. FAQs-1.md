### Sorting based problems

#### 1) Sort array containing 0s and 1s
> Problem Description: <br>
> We are given an array containing only 0s and 1s, we need to sort the array

Approaches:
- Directly sort the array
- Count 0s and 1s and redistribute

Without using extra space
- Similar to quick sort partition
- To maintain one pointer whose job is to store the position of the 1
- When we see any zero, we want to move it to left partition
- So we swap it with the position of 1 (using pointer)

Time Complexity: O(n)
Space Complexity: O(1)
Code:
```java
private void swap(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

void segregate0and1(int[] arr) {
    // code here
    int low = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == 1)
            continue;
        swap(arr, low, i);
        low++;
    }
}
```

#### 2) Sort the array containing 0s, 1s and 2s
Problem Link: https://leetcode.com/problems/sort-colors/description/
> Problem Description: <br>
> We are given an array containing only 0s, 1s and 2s, we need to sort the array
> This algorithm is known as Dutch National Flag Algorithm

Similar to the above problem we will be using partition logic but for both side
- If we get a '0' we try to swap it in the left partition
- If we get a '2' we try to swap it in the right partition
- We maintain two pointers for both of the respective partitions
- zeroPtr: first non zero partition
- twoPtr: last non 2's partition
- When we swap 2 with the right partition
- There is a new element that is coming to current position and be careful not to skip this element
- This could be 0 or 1
- Traverse till the starting if 2's partition to avoid double swaps 

Time Complexity: O(n)
Space Complexity: O(1)
Code:
```java
class Solution {

    private void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    public void sortColors(int[] nums) {
        int n = nums.length;

        // three partitions
        int zeroPtr = 0;
        int mid = 0;
        int twoPtr = n - 1;

        while (mid <= twoPtr) {
            if (nums[mid] == 0) {
                swap(nums, zeroPtr, mid);
                zeroPtr++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else {
                swap(nums, mid, twoPtr);
                twoPtr--;
            }
        }
    }
}
```

